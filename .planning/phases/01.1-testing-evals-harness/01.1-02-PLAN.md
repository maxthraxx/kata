---
phase: 01.1-testing-evals-harness
plan: 02
type: execute
wave: 2
depends_on: [01.1-01]
files_modified:
  - tests/skills/kata-managing-todos.test.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "Test invokes 'check todos' prompt and skill responds"
    - "Test invokes 'add todo: test item' prompt and todo file is created"
    - "Tests run with node --test command"
    - "Tests use temp directory for isolation (no state pollution)"
    - "npm test runs the test suite"
    - "Clear pass/fail output visible"
  artifacts:
    - path: "tests/skills/kata-managing-todos.test.js"
      provides: "Proof-of-concept skill test for kata-managing-todos"
    - path: "package.json"
      provides: "test script for npm test"
      contains: '"test":'
  key_links:
    - from: "tests/skills/kata-managing-todos.test.js"
      to: "tests/harness/claude-cli.js"
      via: "import { invokeClaude }"
      pattern: "import.*invokeClaude.*claude-cli"
    - from: "tests/skills/kata-managing-todos.test.js"
      to: "tests/harness/assertions.js"
      via: "import assertions"
      pattern: "import.*assertSkillInvoked.*assertions"
    - from: "tests/skills/kata-managing-todos.test.js"
      to: "tests/fixtures/kata-project/"
      via: "cpSync for test isolation"
      pattern: "cpSync.*fixtures/kata-project"
---

<objective>
Create proof-of-concept skill test for kata-managing-todos and integrate with npm.

Purpose: Validate the test harness works end-to-end with a real skill. This test will verify both CHECK and ADD operations of the todo skill.

Output:
- tests/skills/kata-managing-todos.test.js (working test file)
- package.json updated with test script
</objective>

<execution_context>
@~/.claude/kata/workflows/execute-plan.md
@~/.claude/kata/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-testing-evals-harness/01.1-RESEARCH.md

# Plan 01 artifacts (dependencies)
@tests/harness/claude-cli.js
@tests/harness/assertions.js

# Skill under test
@skills/kata-managing-todos/SKILL.md

# Existing package.json
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create kata-managing-todos skill test</name>
  <files>tests/skills/kata-managing-todos.test.js</files>
  <action>
Create tests/skills/kata-managing-todos.test.js with skill verification tests:

```javascript
import { describe, it, before, after, beforeEach, afterEach } from 'node:test';
import { mkdtempSync, rmSync, cpSync, existsSync, readdirSync } from 'node:fs';
import { tmpdir } from 'node:os';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { execSync } from 'node:child_process';

import { invokeClaude } from '../harness/claude-cli.js';
import {
  assertSkillInvoked,
  assertNoError,
  assertArtifactExists,
  assertFileMatchesPattern
} from '../harness/assertions.js';

const __dirname = dirname(fileURLToPath(import.meta.url));
const FIXTURES_DIR = join(__dirname, '..', 'fixtures', 'kata-project');

// Path to Kata repo root (for skill installation)
const KATA_ROOT = join(__dirname, '..', '..');

describe('kata-managing-todos skill', () => {
  let testDir;

  beforeEach(() => {
    // Create isolated test directory
    testDir = mkdtempSync(join(tmpdir(), 'kata-test-'));

    // Copy fixture project
    cpSync(FIXTURES_DIR, testDir, { recursive: true });

    // Install kata-managing-todos skill to test project
    const skillSource = join(KATA_ROOT, 'skills', 'kata-managing-todos');
    const skillDest = join(testDir, '.claude', 'skills', 'kata-managing-todos');
    cpSync(skillSource, skillDest, { recursive: true });
  });

  afterEach(() => {
    // Cleanup test directory
    if (testDir && existsSync(testDir)) {
      rmSync(testDir, { recursive: true, force: true });
    }
  });

  describe('CHECK operation', () => {
    it('triggers skill on "check my todos" prompt', async () => {
      const result = invokeClaude('check my todos', {
        cwd: testDir,
        maxBudget: 2.00,
        timeout: 180000  // 3 min for skill execution
      });

      assertNoError(result);
      assertSkillInvoked(result, 'CHECK operation should invoke skill workflow');
    });

    it('triggers skill on "what todos do I have" prompt', async () => {
      const result = invokeClaude('what todos do I have', {
        cwd: testDir,
        maxBudget: 2.00,
        timeout: 180000
      });

      assertNoError(result);
      assertSkillInvoked(result, 'Natural language should trigger skill');
    });
  });

  describe('ADD operation', () => {
    it('creates todo file on "add todo" prompt', async () => {
      const result = invokeClaude('add todo: implement user authentication', {
        cwd: testDir,
        maxBudget: 2.00,
        timeout: 180000
      });

      assertNoError(result);
      assertSkillInvoked(result, 'ADD operation should invoke skill workflow');

      // Verify todo file was created
      const todosDir = join(testDir, '.planning', 'todos', 'pending');
      assertFileMatchesPattern(
        todosDir,
        /.*authentication.*\.md$/i,
        'Todo file should be created with slug from title'
      );
    });
  });
});
```

Design decisions:
- Use describe/it structure for clear test organization
- beforeEach creates fresh isolated environment
- Copy skill into test project's .claude/skills/ (mimics real installation)
- Higher maxBudget ($2) and timeout (3 min) for skill execution
- Separate CHECK and ADD test suites
- Verify both skill invocation (num_turns) AND artifact creation (todo file)

Note: Tests are marked async for consistency but invokeClaude is sync.
The node:test runner handles this correctly either way.
  </action>
  <verify>node --test tests/skills/kata-managing-todos.test.js (runs tests)</verify>
  <done>Test file exists with CHECK and ADD operation tests that verify skill invocation and artifact creation</done>
</task>

<task type="auto">
  <name>Task 2: Update package.json with test script</name>
  <files>package.json</files>
  <action>
Update package.json to add test script and ESM support:

1. Add "type": "module" for ESM support (if not present)

2. Add test script:
```json
"scripts": {
  "test": "node --test tests/**/*.test.js",
  "test:skills": "node --test tests/skills/*.test.js"
}
```

3. Update engines to require Node 20+ (for stable node:test):
```json
"engines": {
  "node": ">=20.0.0"
}
```

The scripts:
- "test" runs all test files
- "test:skills" runs only skill tests (for focused testing)

No additional dependencies needed - using Node.js built-ins only.
  </action>
  <verify>npm test (should discover and run tests)</verify>
  <done>package.json has test script, ESM type, and updated engine requirement</done>
</task>

<task type="auto">
  <name>Task 3: Create test runner entry point with reporter configuration</name>
  <files>tests/harness/runner.js</files>
  <action>
Create tests/harness/runner.js for custom test configuration (optional, for future use):

```javascript
/**
 * Test runner configuration for Kata skill tests.
 *
 * This file provides optional configuration and utilities for the test suite.
 * Tests can be run directly with `node --test` or via this runner for
 * additional features like custom reporters or parallel execution control.
 *
 * Usage:
 *   npm test                    # Run all tests
 *   npm run test:skills         # Run skill tests only
 *   node tests/harness/runner.js # Custom runner (future)
 */

import { run } from 'node:test';
import { spec } from 'node:test/reporters';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { glob } from 'node:fs';

const __dirname = dirname(fileURLToPath(import.meta.url));
const TESTS_DIR = join(__dirname, '..');

// Default configuration
export const config = {
  // Cost limits for different test types
  budgets: {
    quick: 0.50,    // Simple skill trigger tests
    standard: 2.00, // Full skill workflow tests
    expensive: 5.00 // Complex multi-turn tests
  },

  // Timeouts (ms)
  timeouts: {
    quick: 60000,    // 1 min
    standard: 180000, // 3 min
    expensive: 300000 // 5 min
  },

  // Test isolation
  isolation: {
    tempPrefix: 'kata-test-',
    cleanupOnFailure: true
  }
};

// Run tests if this file is executed directly
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  console.log('Kata Test Runner');
  console.log('================');
  console.log('Running: npm test');
  console.log('');

  // For now, just provide helpful output
  // Future: custom parallel execution, cost tracking, etc.
}
```

This provides:
- Documented configuration constants for test budgets/timeouts
- Foundation for future custom runner features
- Self-documenting usage instructions

For now, tests run via npm test (node --test). This file establishes patterns
for future enhancements like parallel execution limits or cost tracking.
  </action>
  <verify>node -e "import('./tests/harness/runner.js')" (ESM import check)</verify>
  <done>runner.js exists with configuration constants and documentation</done>
</task>

</tasks>

<verification>
After all tasks:
- [ ] tests/skills/kata-managing-todos.test.js exists
- [ ] Tests use isolated temp directories
- [ ] Tests copy skill to test project's .claude/skills/
- [ ] Tests verify both skill invocation AND artifact creation
- [ ] package.json has "type": "module"
- [ ] package.json has "test" script
- [ ] npm test discovers and runs test files
- [ ] tests/harness/runner.js exists with configuration
</verification>

<success_criteria>
- Proof-of-concept test validates CHECK and ADD operations
- Tests use temp directories (no state pollution)
- npm test runs the test suite with clear pass/fail output
- Test harness complete and functional end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-testing-evals-harness/01.1-02-SUMMARY.md`
</output>

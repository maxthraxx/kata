---
phase: 01.1-testing-evals-harness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/harness/claude-cli.js
  - tests/harness/assertions.js
  - tests/fixtures/kata-project/.planning/STATE.md
  - tests/fixtures/kata-project/.planning/ROADMAP.md
  - tests/fixtures/kata-project/.planning/todos/pending/.gitkeep
  - tests/fixtures/kata-project/.claude/skills/.gitkeep
autonomous: true

must_haves:
  truths:
    - "invokeClaude() executes claude -p with JSON output and returns parsed object"
    - "invokeClaude() respects cost limits via --max-budget-usd flag"
    - "invokeClaude() uses --allowedTools to prevent permission prompts"
    - "invokeClaude() uses --no-session-persistence for test isolation"
    - "assertSkillInvoked() verifies num_turns > 1 indicating skill execution"
    - "Test fixtures provide minimal Kata project structure"
  artifacts:
    - path: "tests/harness/claude-cli.js"
      provides: "Claude CLI subprocess wrapper with JSON parsing"
      exports: ["invokeClaude"]
    - path: "tests/harness/assertions.js"
      provides: "Custom test assertions for skill verification"
      exports: ["assertSkillInvoked", "assertNoError", "assertArtifactExists"]
    - path: "tests/fixtures/kata-project/"
      provides: "Minimal Kata project structure for test isolation"
  key_links:
    - from: "tests/harness/claude-cli.js"
      to: "claude CLI"
      via: "execSync subprocess"
      pattern: "execSync.*claude"
    - from: "tests/harness/assertions.js"
      to: "tests/harness/claude-cli.js"
      via: "Operates on invokeClaude result object"
      pattern: "result\\.num_turns"
---

<objective>
Create test harness utilities and fixtures for CLI-based skill testing.

Purpose: Establish the foundation for programmatic skill verification using Claude's JSON output mode. These utilities will be reused across all skill tests.

Output:
- tests/harness/claude-cli.js (Claude CLI wrapper)
- tests/harness/assertions.js (custom assertions)
- tests/fixtures/kata-project/ (minimal test project)
</objective>

<execution_context>
@~/.claude/kata/workflows/execute-plan.md
@~/.claude/kata/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-testing-evals-harness/01.1-RESEARCH.md

# Existing package.json for reference
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Claude CLI wrapper utility</name>
  <files>tests/harness/claude-cli.js</files>
  <action>
Create tests/harness/claude-cli.js with invokeClaude() function:

```javascript
import { execSync } from 'node:child_process';

/**
 * Invoke Claude CLI with programmatic flags for testing.
 *
 * @param {string} prompt - The prompt to send to Claude
 * @param {Object} options - Configuration options
 * @param {string} options.cwd - Working directory for execution
 * @param {string} [options.allowedTools='Read,Bash,Glob,Write'] - Tools to allow
 * @param {number} [options.maxBudget=1.00] - Max cost in USD
 * @param {number} [options.timeout=120000] - Timeout in ms
 * @returns {Object} Parsed JSON response from Claude
 */
export function invokeClaude(prompt, options = {}) {
  const {
    cwd,
    allowedTools = 'Read,Bash,Glob,Write',
    maxBudget = 1.00,
    timeout = 120000
  } = options;

  if (!cwd) {
    throw new Error('cwd is required for test isolation');
  }

  const args = [
    '-p', JSON.stringify(prompt),
    '--output-format', 'json',
    '--allowedTools', JSON.stringify(allowedTools),
    '--max-budget-usd', String(maxBudget),
    '--no-session-persistence'
  ];

  const result = execSync(`claude ${args.join(' ')}`, {
    encoding: 'utf8',
    cwd,
    timeout,
    // Capture stderr separately to avoid JSON parsing issues
    stdio: ['pipe', 'pipe', 'pipe']
  });

  return JSON.parse(result);
}
```

Key design decisions:
- Require cwd to enforce test isolation (no accidental real project modification)
- Default maxBudget to $1.00 for cost safety in tests
- Use JSON.stringify for prompt and allowedTools to handle special characters
- Return parsed JSON directly (caller can access .result, .num_turns, etc.)
  </action>
  <verify>node -e "import('./tests/harness/claude-cli.js')" (ESM import check)</verify>
  <done>claude-cli.js exports invokeClaude() with required flags for test isolation</done>
</task>

<task type="auto">
  <name>Task 2: Create custom assertions for skill verification</name>
  <files>tests/harness/assertions.js</files>
  <action>
Create tests/harness/assertions.js with skill-specific assertions:

```javascript
import assert from 'node:assert/strict';
import { existsSync, readdirSync } from 'node:fs';
import { join } from 'node:path';

/**
 * Assert that a skill was invoked (not just ad-hoc response).
 * Skills execute multiple turns; direct answers are typically 1 turn.
 *
 * @param {Object} result - Claude JSON response
 * @param {string} [message] - Custom failure message
 */
export function assertSkillInvoked(result, message) {
  assert.ok(
    result.num_turns > 1,
    message || `Expected skill invocation (num_turns > 1), got ${result.num_turns} turn(s)`
  );
}

/**
 * Assert the response completed without error.
 *
 * @param {Object} result - Claude JSON response
 * @param {string} [message] - Custom failure message
 */
export function assertNoError(result, message) {
  assert.strictEqual(
    result.is_error,
    false,
    message || `Expected no error, but got: ${result.result?.substring(0, 200)}`
  );
}

/**
 * Assert an artifact was created at the expected path.
 *
 * @param {string} basePath - Test directory base path
 * @param {string} relativePath - Expected file/directory path relative to base
 * @param {string} [message] - Custom failure message
 */
export function assertArtifactExists(basePath, relativePath, message) {
  const fullPath = join(basePath, relativePath);
  assert.ok(
    existsSync(fullPath),
    message || `Expected artifact at ${relativePath}, but it does not exist`
  );
}

/**
 * Assert a directory contains at least one file matching a pattern.
 *
 * @param {string} dirPath - Directory to check
 * @param {RegExp} pattern - Pattern to match filenames against
 * @param {string} [message] - Custom failure message
 */
export function assertFileMatchesPattern(dirPath, pattern, message) {
  if (!existsSync(dirPath)) {
    assert.fail(message || `Directory ${dirPath} does not exist`);
  }

  const files = readdirSync(dirPath);
  const matches = files.filter(f => pattern.test(f));

  assert.ok(
    matches.length > 0,
    message || `Expected file matching ${pattern} in ${dirPath}, found: ${files.join(', ') || '(empty)'}`
  );
}

/**
 * Assert response text contains expected content.
 *
 * @param {Object} result - Claude JSON response
 * @param {string|RegExp} expected - String or pattern to match
 * @param {string} [message] - Custom failure message
 */
export function assertResultContains(result, expected, message) {
  const text = result.result || '';

  if (expected instanceof RegExp) {
    assert.ok(
      expected.test(text),
      message || `Expected result to match ${expected}, got: ${text.substring(0, 200)}...`
    );
  } else {
    assert.ok(
      text.includes(expected),
      message || `Expected result to contain "${expected}", got: ${text.substring(0, 200)}...`
    );
  }
}
```

Design decisions:
- Use strict assertions for predictable failures
- Truncate output in error messages to avoid overwhelming test output
- assertSkillInvoked uses num_turns heuristic from research findings
- Include both file existence and content pattern assertions
  </action>
  <verify>node -e "import('./tests/harness/assertions.js')" (ESM import check)</verify>
  <done>assertions.js exports assertSkillInvoked, assertNoError, assertArtifactExists, assertFileMatchesPattern, assertResultContains</done>
</task>

<task type="auto">
  <name>Task 3: Create minimal Kata project fixture</name>
  <files>
    tests/fixtures/kata-project/.planning/STATE.md
    tests/fixtures/kata-project/.planning/ROADMAP.md
    tests/fixtures/kata-project/.planning/todos/pending/.gitkeep
    tests/fixtures/kata-project/.claude/skills/.gitkeep
  </files>
  <action>
Create tests/fixtures/kata-project/ with minimal Kata structure:

1. **tests/fixtures/kata-project/.planning/STATE.md:**
```markdown
# Project State

## Project Reference

**Core value:** Test project for Kata skill verification
**Current focus:** Fixture for automated testing

## Current Position

Milestone: Test
Phase: 0
Plan: 0
Status: Fixture

## Accumulated Context

### Decisions

None.

### Pending Todos

0 pending todos.

### Blockers/Concerns

None.
```

2. **tests/fixtures/kata-project/.planning/ROADMAP.md:**
```markdown
# Roadmap: Test Fixture

## Overview

Minimal project fixture for Kata skill testing.

## Phases

None planned.

## Progress

No phases.
```

3. **tests/fixtures/kata-project/.planning/todos/pending/.gitkeep:**
Empty file (preserves directory in git)

4. **tests/fixtures/kata-project/.claude/skills/.gitkeep:**
Empty file (placeholder for copied skills during tests)

5. **tests/fixtures/kata-project/CLAUDE.md:**
```markdown
# CLAUDE.md

Test project for Kata skill verification.

## Skills

Skills are installed to `.claude/skills/` for this test project.
```

This fixture provides the minimal structure that:
- STATE.md exists (required by many skills)
- ROADMAP.md exists (required by planning skills)
- .planning/todos/pending/ exists (required by todo skill)
- .claude/skills/ exists (for skill installation)
  </action>
  <verify>ls -la tests/fixtures/kata-project/.planning/ shows STATE.md, ROADMAP.md, todos/</verify>
  <done>Minimal Kata project fixture created with required .planning/ structure</done>
</task>

</tasks>

<verification>
After all tasks:
- [ ] tests/harness/claude-cli.js exists and exports invokeClaude
- [ ] tests/harness/assertions.js exists and exports assertion functions
- [ ] tests/fixtures/kata-project/.planning/STATE.md exists
- [ ] tests/fixtures/kata-project/.planning/ROADMAP.md exists
- [ ] tests/fixtures/kata-project/.planning/todos/pending/ directory exists
- [ ] tests/fixtures/kata-project/.claude/skills/ directory exists
- [ ] All files use ESM syntax (import/export)
</verification>

<success_criteria>
- invokeClaude() wraps claude CLI with JSON output, cost limits, tool permissions
- Assertions verify skill invocation (num_turns > 1), errors, artifacts
- Fixture provides minimal but complete Kata project structure
- All utilities can be imported as ESM modules
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-testing-evals-harness/01.1-01-SUMMARY.md`
</output>
